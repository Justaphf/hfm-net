/*
 * HFM.NET - Client Connection Class
 * Copyright (C) 2009-2019 Ryan Harlamert (harlam357)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 2
 * of the License. See the included file GPLv2.TXT.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Text;

using HFM.Client.Internal;

namespace HFM.Client
{
   /// <summary>
   /// Folding@Home client connection class.  Provides functionality for connecting to a Folding@Home client, sending client commands, and receiving raw network data.
   /// </summary>
   public class Connection : IConnection
   {
      private static readonly bool IsRunningOnMono = Type.GetType("Mono.Runtime") != null;

      #region Constants

      /// <summary>
      /// Internal Network Stream Buffer Size
      /// </summary>
      private const int InternalBufferSize = 1024;
      /// <summary>
      /// Default TcpClient Send Buffer Size
      /// </summary>
      private const int DefaultSendBufferSize = 1024 * 8;
      /// <summary>
      /// Default TcpClient Receive Buffer Size
      /// </summary>
      private const int DefaultReceiveBufferSize = 1024 * 8;
      /// <summary>
      /// Default Connection, Send, and Receive Timeout Length
      /// </summary>
      private const int DefaultTimeoutLength = 5000;

      #endregion

      #region Events

      /// <summary>
      /// Occurs when a status update is generated by the Connection.  The data provided by this event is purely informational and should not be used as an indication of the state of the Connection class instance.
      /// </summary>
      public event EventHandler<StatusMessageEventArgs> StatusMessage;
      /// <summary>
      /// Occurs when the value of the Connected property has changed.
      /// </summary>
      public event EventHandler<ConnectedChangedEventArgs> ConnectedChanged;
      /// <summary>
      /// Occurs when data is sent by the Connection.
      /// </summary>
      public event EventHandler<DataEventArgs> DataSent;
      /// <summary>
      /// Occurs when data is received by the Connection.
      /// </summary>
      public event EventHandler<DataEventArgs> DataReceived;

      #endregion

      #region Fields

      private ITcpClient _tcpClient;
      private readonly LockedResource<INetworkStream> _lockedStream;
      private readonly byte[] _internalBuffer;
      private readonly ITcpClientFactory _tcpClientFactory;
      private readonly StringBuilder _readBuffer;

      #endregion

      #region Properties

      /// <summary>
      /// Gets a value indicating whether the Connection is connected to a remote host.
      /// </summary>
      public bool Connected
      {
         get { return _tcpClient.Client != null && _tcpClient.Connected; }
      }

      /// <summary>
      /// Gets or sets the length of time to wait for a response to a connection request (default - 5 seconds).
      /// </summary>
      public int ConnectTimeout { get; set; }

      private int _sendBufferSize = DefaultSendBufferSize;

      /// <summary>
      /// Gets or sets the size of outgoing data buffer (default - 8k).
      /// </summary>
      public int SendBufferSize
      {
         get { return _sendBufferSize; }
         set
         {
            _tcpClient.SendBufferSize = value;
            _sendBufferSize = value;
         }
      }

      private int _receiveBufferSize = DefaultReceiveBufferSize;

      /// <summary>
      /// Gets or sets the size of incoming data buffer (default - 8k).
      /// </summary>
      public int ReceiveBufferSize
      {
         get { return _receiveBufferSize; }
         set
         {
            _tcpClient.ReceiveBufferSize = value;
            _receiveBufferSize = value;
         }
      }

      #endregion

      #region Constructor

      /// <summary>
      /// Initializes a new instance of the Connection class.
      /// </summary>
      [ExcludeFromCodeCoverage]
      public Connection()
         : this(new TcpClientFactory())
      {

      }

      /// <summary>
      /// Initializes a new instance of the Connection class.
      /// </summary>
      internal Connection(ITcpClientFactory tcpClientFactory)
      {
         ConnectTimeout = DefaultTimeoutLength;

         _tcpClientFactory = tcpClientFactory;
         _lockedStream = new LockedResource<INetworkStream>();
         _tcpClient = CreateClient();
         _internalBuffer = new byte[InternalBufferSize];
         _readBuffer = new StringBuilder();
      }

      #endregion

      #region Methods

      /// <summary>
      /// Connect to a Folding@Home client server.
      /// </summary>
      /// <param name="host">Hostname or IP address.</param>
      /// <param name="port">TCP port number.</param>
      /// <exception cref="InvalidOperationException">Connection is already connected.</exception>
      /// <exception cref="ArgumentNullException"><paramref name="host"/> is null.</exception>
      /// <exception cref="TimeoutException">Connection attempt timed out.</exception>
      public void Connect(string host, int port)
      {
         Connect(host, port, String.Empty);
      }

      /// <summary>
      /// Connect to a Folding@Home client server.
      /// </summary>
      /// <param name="host">Hostname or IP address.</param>
      /// <param name="port">TCP port number.</param>
      /// <param name="password">Server password.</param>
      /// <exception cref="InvalidOperationException">Connection is already connected.</exception>
      /// <exception cref="ArgumentNullException"><paramref name="host"/> or <paramref name="password"/> is null.</exception>
      /// <exception cref="TimeoutException">Connection attempt timed out.</exception>
      public void Connect(string host, int port, string password)
      {
         // check connection status, callers should make sure no connection exists first
         if (Connected) throw new InvalidOperationException("Client is already connected.");

         if (host == null) throw new ArgumentNullException("host");
         if (password == null) throw new ArgumentNullException("password");

         if (_tcpClient != null)
         {
            _tcpClient.Dispose();
         }
         _tcpClient = CreateClient();

         IAsyncResult ar = _tcpClient.BeginConnect(host, port, null, null);
         try
         {
            if (!ar.AsyncWaitHandle.WaitOne(TimeSpan.FromMilliseconds(ConnectTimeout), false))
            {
               _tcpClient.Close();
               throw new TimeoutException("Client connection has timed out.");
            }
            if (_tcpClient.Client == null)
            {
               throw new IOException("Client died before establishing a connection.");
            }
            _tcpClient.EndConnect(ar);
            _lockedStream.Set(_tcpClient.GetStream());

            if (password.Length != 0)
            {
               // send authentication
               SendCommand("auth " + password);
            }
            if (Connected)
            {
               // send connected event
               OnConnectedChanged(new ConnectedChangedEventArgs(true)); // maybe use Connected property?
               // send status message
               OnStatusMessage(new StatusMessageEventArgs(String.Format(CultureInfo.CurrentCulture,
                  "Connected to {0}:{1}", host, port)));
               // start listening for messages
               // from the network stream
               Update();
            }
         }
         finally
         {
            /*
             * when running on Mono, if we time out connecting,
             * TcpClient.Close() (above) causes asynchronous access
             * (coming from BeginConnect-related path) to AsyncWaitHandle.
             * This opens a race window with closing the handle below.
             *
             * Unfortunate chain of events results in the following:

Unhandled Exception: System.ObjectDisposedException: The object was used after being disposed.
  at System.Threading.WaitHandle.CheckDisposed ()
  at System.Threading.EventWaitHandle.Set ()
  at (wrapper remoting-invoke-with-check) System.Threading.EventWaitHandle:Set ()
  at System.Net.Sockets.Socket+SocketAsyncResult.set_IsCompleted (Boolean value)
  at System.Net.Sockets.Socket+SocketAsyncResult.Complete ()
  at System.Net.Sockets.Socket+SocketAsyncResult.Complete (System.Exception e)
  at System.Net.Sockets.Socket+Worker.Connect ()
  at System.Net.Sockets.Socket+Worker.DispatcherCB (System.Net.Sockets.SocketAsyncResult sar)

             * As Mono's TcpClient.Close() signals AsyncWaitHandle, we can
             * just wait on it before proceeding.
             *
             * Note: we can't wait on the handle right after closing TcpClient
             * because closing the client may throw.
             *
             */
            if (IsRunningOnMono)
            {
               ar.AsyncWaitHandle.WaitOne();
            }

            ar.AsyncWaitHandle.Close();
         }
      }

      private ITcpClient CreateClient()
      {
         var tcpClient = _tcpClientFactory.Create();
         tcpClient.SendBufferSize = SendBufferSize;
         tcpClient.ReceiveBufferSize = ReceiveBufferSize;
         tcpClient.NoDelay = true;
         return tcpClient;
      }

      /// <summary>
      /// Close the connection to the Folding@Home client server.
      /// </summary>
      public void Close()
      {
         // close the network stream
         _lockedStream.Release();
         // close the connection
         _tcpClient.Close();
         // send connected event
         OnConnectedChanged(new ConnectedChangedEventArgs(false));
         // send status message
         OnStatusMessage(new StatusMessageEventArgs("Connection closed."));
      }

      /// <summary>
      /// Send a command to the Folding@Home client server.
      /// </summary>
      /// <param name="command">Command text.  Null, empty, or whitespace strings will be ignored.</param>
      /// <exception cref="InvalidOperationException">Connection is not connected.</exception>
      /// <remarks>Callers should make sure the Connection is connected by checking the value of the Connected property.</remarks>
      public void SendCommand(string command)
      {
         // check connection status, callers should make sure they're connected first
         if (!Connected) throw new InvalidOperationException("Connection is not connected.");

         if (command == null || command.Trim().Length == 0)
         {
            OnStatusMessage(new StatusMessageEventArgs("No command text given."));
            return;
         }

         if (!command.EndsWith("\n", StringComparison.Ordinal))
         {
            command += "\n";
         }
         byte[] buffer = Encoding.ASCII.GetBytes(command);

         AsyncCallback callback = result =>
         {
            try
            {
               _lockedStream.Execute(x => x.EndWrite(result));
               // send data sent event
               OnDataSent(new DataEventArgs(command, buffer.Length));
               // send status message
               OnStatusMessage(new StatusMessageEventArgs(String.Format(CultureInfo.CurrentCulture,
                  "Sent command: {0} ({1} bytes)", CleanUpCommandText(command), buffer.Length)));
            }
            catch (Exception ex)
            {
               OnStatusMessage(new StatusMessageEventArgs(String.Format(CultureInfo.CurrentCulture,
                  "Write failed: {0}", ex.Message), ex));
               Close();
            }
         };

         try
         {
            _lockedStream.Execute(x => x.BeginWrite(buffer, 0, buffer.Length, callback, null));
         }
         catch (IOException ex)
         {
            OnStatusMessage(new StatusMessageEventArgs(String.Format(CultureInfo.CurrentCulture,
               "Write failed: {0}", ex.Message), ex));
            Close();
         }
      }

      private static string CleanUpCommandText(string command)
      {
         Debug.Assert(command != null);
         return command.Replace("\n", String.Empty);
      }

      //private static bool IsCancelBlockingCallSocketError(Exception ex)
      //{
      //   var ioEx = ex as System.IO.IOException;
      //   if (ioEx != null)
      //   {
      //      var socketEx = ioEx.InnerException as SocketException;
      //      // code 10004 is WSACancelBlockingCall
      //      if (socketEx != null && socketEx.ErrorCode == 10004)
      //      {
      //         return true;
      //      }
      //   }
      //   return false;
      //}

      /// <summary>
      /// Update the local data buffer with data from the remote network stream.
      /// </summary>
      private void Update()
      {
         AsyncCallback callback = null;
         callback = result =>
         {
            if (!_lockedStream.IsAvailable)
            {
               return;
            }

            int bytesRead;
            int totalBytesRead = (int)result.AsyncState;
            try
            {
               bytesRead = _lockedStream.Execute(x => x.EndRead(result));
               if (bytesRead == 0)
               {
                  OnStatusMessage(new StatusMessageEventArgs(String.Format(CultureInfo.CurrentCulture,
                     "Update failed: {0}", "The underlying socket has been closed.")));
                  Close();
                  return;
               }
            }
            catch (Exception ex)
            {
               //if (!IsCancelBlockingCallSocketError(ex))
               //{
                  OnStatusMessage(new StatusMessageEventArgs(String.Format(CultureInfo.CurrentCulture,
                     "Update failed: {0}", ex.Message), ex));
               //}
               Close();
               return;
            }

            _readBuffer.Append(Encoding.ASCII.GetChars(_internalBuffer, 0, bytesRead));
            totalBytesRead += bytesRead;

            if (_lockedStream.Execute(x => x.DataAvailable))
            {
               _lockedStream.Execute(x => x.BeginRead(_internalBuffer, 0, _internalBuffer.Length, callback, totalBytesRead));
               return;
            }

            string buffer = _readBuffer.ToString();
            _readBuffer.Clear();
            ProcessData(buffer, totalBytesRead);

            try
            {
               _lockedStream.Execute(x => x.BeginRead(_internalBuffer, 0, _internalBuffer.Length, callback, 0));
            }
            catch (IOException ex)
            {
               OnStatusMessage(new StatusMessageEventArgs(String.Format(CultureInfo.CurrentCulture,
                  "Update failed: {0}", ex.Message), ex));
               Close();
            }
         };

         _lockedStream.Execute(x => x.BeginRead(_internalBuffer, 0, _internalBuffer.Length, callback, 0));
      }

      protected internal virtual void ProcessData(string buffer, int totalBytesRead)
      {
         OnDataReceived(new DataEventArgs(buffer, totalBytesRead));
      }

      /// <summary>
      /// Raise the StatusMessage event.
      /// </summary>
      /// <param name="e">Event arguments (if null the event is cancelled).</param>
      protected virtual void OnStatusMessage(StatusMessageEventArgs e)
      {
         if (e == null) return;

         Debug.WriteLine(e.Status);

         StatusMessage?.Invoke(this, e);
      }

      private void OnConnectedChanged(ConnectedChangedEventArgs e)
      {
         ConnectedChanged?.Invoke(this, e);
      }

      private void OnDataSent(DataEventArgs e)
      {
         DataSent?.Invoke(this, e);
      }

      private void OnDataReceived(DataEventArgs e)
      {
         DataReceived?.Invoke(this, e);
      }

      #endregion

      #region IDisposable Members

      private bool _disposed;

      /// <summary>
      /// Releases all resources used by the Connection.
      /// </summary>
      public void Dispose()
      {
         Dispose(true);
         GC.SuppressFinalize(this);
      }

      /// <summary>
      /// Releases the unmanaged resources used by the Connection and optionally releases the managed resources.
      /// </summary>
      protected virtual void Dispose(bool disposing)
      {
         if (!_disposed)
         {
            if (disposing)
            {
               // close connection
               Close();
            }
         }

         _disposed = true;
      }

      /// <summary>
      /// Releases unmanged resources used by the Connection.
      /// </summary>
      ~Connection()
      {
         Dispose(false);
      }

      #endregion
   }

   /// <summary>
   /// Provides data for status message events of a Connection. This class cannot be inherited.
   /// </summary>
   public sealed class StatusMessageEventArgs : EventArgs
   {
      /// <summary>
      /// Gets the status message text.
      /// </summary>
      public string Status { get; }

      /// <summary>
      /// Gets the Exception included with this message.
      /// </summary>
      public Exception Exception { get; }

      /// <summary>
      /// Initializes a new instance of the StatusMessageEventArgs class.
      /// </summary>
      /// <param name="status">The status message text.</param>
      /// <exception cref="System.ArgumentNullException"><paramref name="status"/> is null.</exception>
      public StatusMessageEventArgs(string status)
      {
         Status = status ?? throw new ArgumentNullException(nameof(status));
      }

      /// <summary>
      /// Initializes a new instance of the StatusMessageEventArgs class.
      /// </summary>
      /// <param name="status">The status message text.</param>
      /// <param name="exception">The exception to include with this message.</param>
      /// <exception cref="System.ArgumentNullException"><paramref name="status"/> is null.</exception>
      public StatusMessageEventArgs(string status, Exception exception)
      {
         Status = status ?? throw new ArgumentNullException(nameof(status));
         Exception = exception;
      }
   }

   /// <summary>
   /// Provides data for connection status events of a Connection. This class cannot be inherited.
   /// </summary>
   public sealed class ConnectedChangedEventArgs : EventArgs
   {
      /// <summary>
      /// Gets the connection status.
      /// </summary>
      public bool Connected { get; }

      internal ConnectedChangedEventArgs(bool connected)
      {
         Connected = connected;
      }
   }

   /// <summary>
   /// Provides data for sent and received events of a Connection. This class cannot be inherited.
   /// </summary>
   public sealed class DataEventArgs : EventArgs
   {
      /// <summary>
      /// Gets the data text value.
      /// </summary>
      public string Value { get; }

      /// <summary>
      /// Gets the data length in bytes.
      /// </summary>
      public int Length { get; }

      internal DataEventArgs(string value, int length)
      {
         Value = value;
         Length = length;
      }
   }
}
